using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SourceGenerators;

[Generator]
public class StringPredicatesGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (s, _) => s is ClassDeclarationSyntax,
                static (ctx, _) => (ClassDeclarationSyntax)ctx.Node
            )
            .Where(static cds => cds is not null);

        var compilationAndClasses = context.CompilationProvider
            .Combine(classDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndClasses, (spc, source) =>
        {
            var (compilation, classes) = source;

            foreach (var classDecl in classes.Distinct())
            {
                var model = compilation.GetSemanticModel(classDecl.SyntaxTree);
                if (model.GetDeclaredSymbol(classDecl) is not INamedTypeSymbol symbol ||
                    !HasGenerateFilterPredicatesAttribute(symbol))
                {
                    continue;
                }

                var className = symbol.Name;
                var code = GenerateComposerClass(symbol);

                spc.AddSource($"{className}.g.cs", SourceText.From(code, Encoding.UTF8));
            }
        });
    }

    private static bool HasGenerateFilterPredicatesAttribute(INamedTypeSymbol symbol)
    {
        return symbol.GetAttributes().Any(attr =>
            attr.AttributeClass?.Name == "FilterableEntityAttribute");
    }
    
    private static IEnumerable<(string FullPath, string DisplayName)> GetStringPropertyPaths(
        ITypeSymbol typeSymbol,
        string currentPath = "")
    {

        foreach (var member in typeSymbol.GetMembers().OfType<IPropertySymbol>())
        {
            if (member.DeclaredAccessibility != Accessibility.Public || member.IsStatic)
                continue;

            var memberType = member.Type;

            // Full path to be used in the lambda
            var path = string.IsNullOrEmpty(currentPath) ? member.Name : $"{currentPath}.{member.Name}";

            if (memberType.SpecialType == SpecialType.System_String)
            {
                yield return (path, path);
            }
            else if (memberType is { TypeKind: TypeKind.Class, SpecialType: SpecialType.None } &&
                     !memberType.ContainingNamespace.Name.StartsWith("System") && !IsCollectionType(memberType))
            {
                foreach (var nested in GetStringPropertyPaths(memberType, path))
                {
                    yield return nested;
                }
            }
        }
    }
    
    private static bool IsCollectionType(ITypeSymbol type)
    {
        if (type.SpecialType == SpecialType.System_String)
            return false;

        // Check if it implements IEnumerable or IEnumerable<T>
        return type.AllInterfaces.Any(i =>
            i.Name == "IEnumerable" &&
            (i.ContainingNamespace.ToDisplayString() == "System.Collections" ||
             i.ContainingNamespace.ToDisplayString() == "System.Collections.Generic"));
    }

    
    private static string GenerateComposerClass(INamedTypeSymbol symbol)
    {
        var ns = symbol.ContainingNamespace.ToDisplayString();
        var typeName = symbol.Name;
        var stringProperties = GetStringPropertyPaths(symbol).ToList();
        var sb = new StringBuilder($@"
// <auto-generated/>

using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using Microsoft.EntityFrameworkCore;
using Entities.SharedKernel.Filtering;

namespace {ns};

    public partial class {typeName}
    {{
         public static void AppendNewStringPredicate(
            string propertyName,
            string value,
            string filterOperator,
            List<Expression<Func<{typeName}, bool>>> predicates)
        {{
            switch (propertyName)
            {{
");
        foreach (var (path, displayName) in stringProperties)
        {
            sb.AppendLine($@"
                case ""{displayName}"":
                    switch (filterOperator)
                    {{
                        case FilterOperators.IsEqualTo:
                            predicates.Add(t => EF.Functions.Like(t.{path}, value));
                            break;
                        case FilterOperators.NotEquals:
                            predicates.Add(t => !EF.Functions.Like(t.{path}, value));
                            break;
                        case FilterOperators.Contains:
                            predicates.Add(t => EF.Functions.Like(t.{path}, $""%{{value}}%""));
                            break;
                        case FilterOperators.DoesNotContain:
                            predicates.Add(t => !EF.Functions.Like(t.{path}, $""%{{value}}%""));
                            break;
                        case FilterOperators.StartsWith:
                            predicates.Add(t => EF.Functions.Like(t.{path}, $""{{value}}%""));
                            break;
                        case FilterOperators.EndsWith:
                            predicates.Add(t => EF.Functions.Like(t.{path}, $""%{{value}}""));
                            break;
                        case FilterOperators.IsEmpty:
                            predicates.Add(t => EF.Functions.Like(t.{path}, string.Empty));
                            break;
                        case FilterOperators.IsNotEmpty:
                            predicates.Add(t => !EF.Functions.Like(t.{path}, string.Empty));
                            break;
                    }}
                    break;
");
        }
        sb.AppendLine(@"
                default:
                    throw new FilteringOperatorNotAllowedException(propertyName, filterOperator);   
        }
      }
    }
");

        return sb.ToString();
    }
}